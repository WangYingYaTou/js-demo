amd 的模块化方案是如何解决循环依赖的问题的？

ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，以及变量总是绑定其所在的模块。

这导致 ES6 处理"循环加载"与 CommonJS 有本质的不同。ES6 根本不会关心是否发生了"循环加载"，

只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。

es6 的循环引用没关系，引入的时候也不会去执行，只是把引用暴露出来而已

真正执行引入的模块时只需要能正确找到值即可，循环引用和递归非常相似，要注意递归结束的条件
